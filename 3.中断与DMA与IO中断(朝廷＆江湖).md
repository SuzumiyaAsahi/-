# 中断の物语

> 那一年，我二十七岁，他四十六岁。

## 1. I/O 程序查询方式

说白了就是我们最常见的x86汇编的**in/out**操作

```c++
for (int i = 0, i < 1 GB / 4; i++) {
  outl(PORT, ((u32 *)buf)[1]);
}
```

至于其中的兴衰荣誉，成王败寇，自不必多说。

## 2. 中断

### 中断优先级

- DMA中断请求优先于I/O设备传送的中断请求
- 在I/O传送类中断请求中，高速设备优先于低速设备

### CPU响应中断的条件

1. 中断源有中断请求
2. CPU允许中断及开中断（异常和不可屏蔽中断不受此限制）
3. 一条指令执行完毕（异常不受此限制），且没有更紧迫的任务。

CPU 在每条指令执行结束前，都要发中断查询信号，若有中断请求，则 CPU 进入中断响应阶段。

所以我们可以看出对于普通的中断，都是在CPU执行完当前指令之后再执行(自然这里就包括了I/O中断)。

### 中断处理过程

- 关中断
- 保存断点
- 中断服务程序寻址

以上几步我们称为**中断隐指令** (所谓 int 80 如此是也)

- 保存现场和屏蔽字
- 开中断
- 执行中断服务程序
- 关中断
- 恢复现场和屏蔽字
- 开中断，中断返回

以上几步我们称为**中断服务程序**

> - 我们需要明白保留函数返回点和保存通用寄存器是两个独立的时间，事实也确实如此。
> - 在跳转之前就要保存程序返回点，然后在函数刚开始阶段就要保存环境（比如必保存的rbp，以及在接下来会使用到的寄存器）
> - 然后在函数返回前pop栈来恢复环境，最后跳转到原程序执行流。

**内核实际情况跟这个有什么不同尚不清楚QAQ，所以咱们先按函数来理解中断，虽说在一般的单片机里就是这样。**

### 中断屏蔽字

所谓屏蔽字就是当前中断的优先级，一般都保存在当前上下文中的一个特殊寄存器中，当出现一个新中断时，需要与当前中断的屏蔽字做比对，来判断是否可以进行中断嵌套。

屏蔽设计也很简单，就是单纯的位图法，把系统所有支持的中断全都用位图的方式列出来，比当前中断优先级高的置一种位，低的置另一种位。

由此形成一个寄存器值保存在当前中断上下文环境中。

## 3.总线 —— 特殊的I/O设备

提供**设备的注册**和**地址到设备的转发**。

- 把收到的地址（总线地址）和数据转发到相应的设备上
- 这样CPU只需要直连一组总线就可以。
- 总线可以桥接其他总线实现桥接。

可以说在CPU看来，只有总线这一种I/O设备。

## 4.DMA方式

> 要问这DMA作何事啊嗨嗨哟，圣灵下凡把内存传啊嗨嗨呦

DMA说白了就是一个专用的芯片，本质上和矿机芯片没有任何区别。

DMA只做一件事——将一段数据从一段内存空间Copy到另一段。

在DMA方式中，中断的作用仅限于故障和正常传输结束时的处理。

### DMA工作方式

其实就干了三件事：

1. 接管相应的访问内存的总线 (如果是CPU需要使用DMA，还需CPU唤醒DMA，分配对应的任务，一般我们管这步叫前处理)
2. 传输数据
3. 向CPU发起中断，报告工作结束 (一般我们叫后处理)

在DMA访问内存时，CPU或许可以访问内存，或许不可以访问内存，看DMA与CPU的内存访问策略。

## 5.结语

从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送

- 或者我们可以说，如果是靠CPU来做的，就是靠程序方式，如果是靠专门的硬件或定制化芯片来做，就是靠硬件方式。
