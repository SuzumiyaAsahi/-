# 你说话算数吗？

## 移位

- 算数移位是保存符号位的，无论是左移还是右移。
- 逻辑移位是不保存符号位的。

## 补码运算

补码的负数就是**取反再加一**

加法器在处理补码减法操作时都是

$$
A - B = A + (- B)
$$

我们在处理补码运算时只能获得关于OF标志位的结果(通过检查双符号位是否一致)。

虽说绝大多数情况下可以通过笔算十六进制判断出来。

想知道CF标志位的信息，就需要进行原码计算。(竖式计算)

## (补码)最大与最小

如果知道位数，最大值等于

$$
2^{n - 1} - 1
$$

最小值等于

$$
- 2^{n-1}
$$

具体到二进制位(以unsigned char为例)上，最大值等于

$$
\texttt{0111 1111}
$$

最小值等于

$$
\texttt{1000 0000}
$$

## 机器数与机器代码

机器数就是普通的数字而已，有时会按双字节分开是为了阅读方便，并无其他意思。

机器代码并不是，它是按照gdb的方式来书写的。

## 圣听

### 为什么有符号整数加减、无符号整数加减运算可以使用同一个加法器辅助电路实现？

n位加法器实现的是模*2^n*无符号整数加法运算，对于无符号整数a和b，a+b可以直接用加法器实现，而a-b可用a加-b的补数实现，即

$$
[a + b] = a + [b]_{\text{补}} \pmod{2^n}
$$

所以n位无符号整数加减运算都可在n位加法器中实现。

由于有符号整数用补码表示，补码加减运算公式为

$$
\begin{align}
[a + b]_{\text{补}} &= [a]_{\text{补}} + [b]_{\text{补}} \pmod{2^n} \\

[a - b]_{\text{补}} &= [a]_{\text{补}} + [-b]_{\text{补}} \pmod{2^n}
\end{align}
$$

所以n位有符号整数加减运算都可在n位加法器中实现。

### 若芯片的指令系统没有乘法指令，但有加法、减法和位移等指令，则在M上为什么也能实现乘法运算？

乘法运算可以通过加法和移位来实现，编译器可以将乘法运算转换为一个循环代码段，在循环代码段中通过比较，加法和移位等指令实现乘法运算。

### 针对以下三种情况：a）没有乘法指令；b）有使用ALU和位移器实现的乘法指令；c）有使用阵列乘法器实现的乘法指令。那种情况乘法执行的时间最长，在那种情况下执行的时间最短？

a最长，c最短。对于a，需要用循环程序段实现乘法操作，因而需要反复执行很多条指令，而每条指令都需要取指令，译码，取数，执行并保存结果，所以执行时间很长；对于b和c，都只需用一条乘法指令实现乘法操作，不过b中的乘法指令，需要多个时钟周期才能完成，而c中的乘法指令可在一个时钟周期内完成，所以c的执行时间最短。
