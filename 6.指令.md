# 指令中或许有我，也可能没有

## 指令格式

往往就是规定指令的长度和是几地址指令。

## 数据寻址方式

### 操作码与操作数

|  操作码  |      操作数       | 操作数 |
| :------: | :---------------: | :----: |
|   and    |        al         |  0x08  |
| mov byte | [bx + si + 0x100] |   al   |

- 第一条指令中, al 和 0x08 是操作数
- 第二条指令中，[bx + si + 0x100] 才是操作数，bx + si + 0x100 并不是操作数。

### 形式地址

```c
add word [0x0230], 0x5000;
mov byte [bx + 0x100], al;
```

这里的 0x0230 和 0x100 都是形式地址，在不是直接寻址的情况下可以看做是 offset。

### 立即(数)寻址

```c
mov dx, 0xf000;
```

其实说白了就是加载立即数，和寻址半毛钱关系都没有

### 寄存器寻址

```c
mov ax, cx;
add bx, 0xf000;
```

就是直接使用寄存器运算，虽说某种意义上讲也算是寻址。

### 直接寻址

```c
add word [0x0230], 0x5000;
```

### 间接寻址

```c
mov byte bx ,[[0x230]];
```

虽说现实中没这事。

### 寄存器间接寻址

```c
mov byte [bx], 0x20;
```

### 基址寻址

```c
mov byte [bx + 0x10], 0xdeadbeef;
```

这里的基址指的是**基址寄存器**，虽然基址寄存器这个概念已经消失了。

### 变址寻址

```c
mov [si], 0x20;
xor word [di], 0x2000;
```

这里的变址指的是**变址寄存器**，虽然和基址寄存器一样也变成历史的天空力。

### 基址变址寻址

```c
mov [bx + si + 0x100], al;
add byte [bx + di + label_a], 0x80;
```

两个寄存器同台演义？

### 相对寻址

```c
jmp near infinite;
jmp short 0x2000;
```

课本原话是 EA = （PC）+ A, 同时操作数可以为负数，即操作数使用**补码**

同时还需注意

```c
jal x1, main
```

其中

$$
x[\text{rd}] = \text{pc} + 4; \\
\text{pc} += \text{sext}(\text{offset});
$$

同时 offset 要进行符号扩展，rd 等于 pc + 4

但实际上，一个指令32位，CPU是先读完指令再执行，所以此时pc已经等于 pc + 4

这就意味着

$$
\text{main} = \text{main的相对地址} - (\text{pc} + 4)
$$

## FLAG寄存器

### 奇偶标志位PF

当运算结果出来后，如果最低8位中，有偶数个为1的比特，则PF=1，否则PF=0。

> 有些指令，例如mov，jmp是没有运算结果的

### 进位标志CF

当处理器进行算数操作时，如果最高位有向前进位或借位的情况发生，则CF=1；否则CF=0。

```c
mov al, 10000000B;
mov al, al;
```

这里实际AL发生了加法溢出，溢出到了**最高位的前一位**，所以CF=1。

```c
mov ax, 0;
sub ax, 1;
```

这里ax发生了向最高位前一位借位，实际发生了减法溢出，所以CF=1。

CF标志始终忠实地记录进位或者借位是否发生，但少数指令除外（如 inc 和 dec )

### 溢出标志OF

```c
mov ah, 0xff;
add ah, 2;
```

这里进位标志CF为1，但是OF为0，因为 -1 + 2 = 1 计算结果正确。

```c
mov ah, 0x70;
add ah, ah;
```

这里进位标志CF为0，因为

$$
01110000 + 01110000 = 11100000
$$

最高位没有进位，故CF=0

但是从有符号运算的角度上看

$$
112 + 112 = -32
$$

发生了有符号数计算的溢出，所以OF=1

### 指令比较运算

至于一些如cmp，jng，jle等分支判断指令均是通过将操作数做减法，然后观察标志位的变化来做的判断。

### 标志位总结

CF是检测无符号运算有没有发生溢出，OF是检测有符号运算有没有发生溢出。

OF是通过**双符号位**在计算之后是否一致来判断是否溢出的。

CF则是通过**原码**运算过程中有没有发生进位，减法运算有没有发生借位。

OF位判断和CF位判断需要通过两次运算来判断（人工），一次是补码运算，一次是原码运算。

## CISC 和 RISC

### CISC的主要特点（我不知道的）

1. 指令的长度不固定，指令格式多，寻址方式多
2. 可以访存的指令不受限制
3. 各种指令的执行时间相差很大，大多数指令需多个时钟周期才能完成。
4. 控制器大多数采用微程序控制，有些指令非常复杂，以至于无法采用硬连线控制。

### RISC的主要特点（还是我不知道的）

RISC 的中心思想是要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致。

1. 选取使用频率最高的一些简单指令，复杂指令的功能由简单的指令的组合来实现。
2. 指令长度固定，指令格式种类少，寻址方式种类少。
3. 只有 Load/Store (取数/存数) 指令访存，其余指令的操作都在寄存器之间运行。
4. CPU中通用寄存器的数量相当多。
5. RISC一定是采用流水线技术，大多数指令在一个时钟周期内完成
6. 硬布线控制为主，不用或少用微程序控制

## 操作码与操作数的位置

实际上，在绝大多数指令集中，一条指令的操作码在低位，操作数在高位。
